<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ジャンル別売上ビューア ver3.9</title>
<script src="./genre_map.full.js"></script>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    select, button { margin: 0.5rem; padding: 0.4rem; }
    #output { margin-top: 2rem; }
    .error { color: red; }
  </style>
</head>
<body>
  <h1>ジャンル別売上ビューア ver3.9</h1>

  <label for="startMonth">開始月: </label>
  <input type="month" id="startMonth" value="2022-09">
  <label for="endMonth">終了月: </label>
  <input type="month" id="endMonth" value="2022-09">
  <br>

  <label>ジャンル選択: </label>
  <select id="genreSelect1"></select>
  <select id="genreSelect2" style="display:none;"></select>
  <select id="genreSelect3" style="display:none;"></select>
  <select id="genreSelect4" style="display:none;"></select>
  <select id="genreSelect5" style="display:none;"></select>
  <br>

  <button id="loadBtn">表示</button>
  <div id="output"></div>

  <script>
    import {{ genreMap }} from './genre_map.full.js';

    const genreTreeUrl = "./genre_tree_merged.json";
    let genreTree = null;

    const selects = [
      document.getElementById("genreSelect1"),
      document.getElementById("genreSelect2"),
      document.getElementById("genreSelect3"),
      document.getElementById("genreSelect4"),
      document.getElementById("genreSelect5")
    ];

    async function fetchGenreTree() {
      const res = await fetch(genreTreeUrl);
      if (!res.ok) throw new Error("ジャンルツリーの取得に失敗しました");
      return await res.json();
    }

    function populateSelect(select, options) {
      select.innerHTML = "<option value=''>選択してください</option>";
      for (const key of Object.keys(options)) {
        const opt = document.createElement("option");
        opt.value = key;
        opt.textContent = key;
        select.appendChild(opt);
      }
    }

    function clearLowerSelects(index) {
      for (let i = index + 1; i < selects.length; i++) {
        selects[i].style.display = "none";
        selects[i].innerHTML = "";
      }
    }

    function getSelectedPath() {
      return selects.map(s => s.value).filter(v => v);
    }

    function findGenreNode(path) {
      let node = genreTree;
      for (const segment of path) {
        node = node[segment];
        if (!node) break;
      }
      return node;
    }

    function setupSelects() {
      populateSelect(selects[0], genreTree);
      selects[0].style.display = "inline";
      for (let i = 0; i < selects.length; i++) {
        selects[i].addEventListener("change", () => {
          const path = getSelectedPath();
          clearLowerSelects(i);
          const node = findGenreNode(path);
          if (node && typeof node === "object") {
            const next = selects[i + 1];
            if (next) {
              populateSelect(next, node);
              next.style.display = "inline";
            }
          }
        });
      }
    }

    function getGenreKey(path) {
      for (let i = path.length; i > 0; i--) {
        const subPath = path.slice(0, i).join(">");
        if (window.genreMap[subPath]) return window.genreMap[subPath];
      }
      return null;
    }

    function getMonths(start, end) {
      const [sy, sm] = start.split("-").map(Number);
      const [ey, em] = end.split("-").map(Number);
      const months = [];
      for (let y = sy; y <= ey; y++) {
        for (let m = 1; m <= 12; m++) {
          if ((y === sy && m < sm) || (y === ey && m > em)) continue;
          months.push(`${y}${m.toString().padStart(2, "0")}`);
        }
      }
      return months;
    }

    async function fetchCsvData(fileUrl) {
      try {
        const res = await fetch(fileUrl);
        if (!res.ok) return null;
        const text = await res.text();
        return text.trim().split("\n").map(line => line.split(","));
      } catch {
        return null;
      }
    }

    document.getElementById("loadBtn").addEventListener("click", async () => {
      const output = document.getElementById("output");
      output.innerHTML = "";
      const path = getSelectedPath();
      if (path.length === 0) {
        output.innerHTML = "<div class='error'>ジャンルを選択してください。</div>";
        return;
      }

      const fileKey = getGenreKey(path);
      if (!fileKey) {
        output.innerHTML = "<div class='error'>対応するCSVファイル名が見つかりませんでした：" + path.join(">") + "</div>";
        return;
      }

      const months = getMonths(
        document.getElementById("startMonth").value,
        document.getElementById("endMonth").value
      );

      let dataMap = new Map();
      for (const month of months) {
        const fileName = `./data/${fileKey}_${month}.csv`;
        const rows = await fetchCsvData(fileName);
        if (!rows) continue;
        for (const [genre, value] of rows) {
          const val = Number(value);
          if (!isNaN(val)) {
            dataMap.set(genre, (dataMap.get(genre) || 0) + val);
          }
        }
      }

      if (dataMap.size === 0) {
        output.innerHTML = "<div class='error'>該当データが見つかりませんでした。</div>";
        return;
      }

      const table = document.createElement("table");
      table.border = "1";
      const header = table.insertRow();
      header.insertCell().textContent = "ジャンル名";
      header.insertCell().textContent = "合計金額";
      for (const [genre, total] of dataMap.entries()) {
        const row = table.insertRow();
        row.insertCell().textContent = genre;
        row.insertCell().textContent = total.toLocaleString();
      }
      output.appendChild(table);
    });

    fetchGenreTree().then(tree => {
      genreTree = tree;
      setupSelects();
    }).catch(err => {
      document.getElementById("output").innerHTML = "<div class='error'>" + err.message + "</div>";
    });
  </script>
</body>
</html>
